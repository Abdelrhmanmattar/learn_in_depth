/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//RCC address
#define RCC_BASE 0x40021000
#define RCC_APB2ENR *(volatile uint32_t *)(RCC_BASE + 0x18)

// GPIOA address
#define GPIOA_BASE 0x40010800
#define GPIOA_CRL *(volatile uint32_t *)(GPIOA_BASE + 0x00)
#define GPIOA_CRH *(volatile uint32_t *)(GPIOA_BASE + 0x04)
#define GPIOA_IDR *(volatile uint32_t *)(GPIOA_BASE + 0x08)
#define GPIOA_ODR *(volatile uint32_t *)(GPIOA_BASE + 0x0C)


// GPIOB address
#define GPIOB_BASE 0x40010C00
#define GPIOB_CRL *(volatile uint32_t *)(GPIOB_BASE + 0x00)
#define GPIOB_CRH *(volatile uint32_t *)(GPIOB_BASE + 0x04)
#define GPIOB_IDR *(volatile uint32_t *)(GPIOB_BASE + 0x08)
#define GPIOB_ODR *(volatile uint32_t *)(GPIOB_BASE + 0x0C)



//MACROS
#define set_bit(reg,bit) reg |= (1<<bit)
#define clear_bit(reg,bit) reg &= ~(1<<bit)
#define READ_BIT(reg,bit)    ((reg&(1<<bit))>>bit)
#define TOG_BIT(reg,bit)    reg^=(1<<bit)


//Function prototypes
void clock_init(void);
void gpio_init(void);

void _delay(uint32_t delay)
{
  for(uint32_t i=0;i<delay;i++)
  {
    for(uint32_t j=0;j<500;j++);
  }
}

int main(void)
{
  //Initialize clock
  clock_init();
  //Initialize GPIO
  gpio_init();
    /* Loop forever */
  while(1)
  {
    if(READ_BIT(GPIOA_IDR,1) == 0)
    {
      TOG_BIT(GPIOB_ODR,1);
      while((READ_BIT(GPIOA_IDR,1)) == 0);
    }
    if((READ_BIT(GPIOA_IDR,13)) == 1)
    {
      TOG_BIT(GPIOB_ODR,13);
      _delay(5);
    }
    _delay(10);
  }
}

void clock_init(void)
{
  //Enable clock for GPIOA
  set_bit(RCC_APB2ENR,2);
  //Enable clock for GPIOB
  set_bit(RCC_APB2ENR,3);
}

void gpio_init(void)
{
  //set PB1 as output
  //MODE -> 01: Output mode, max speed 10 MHz
  //CNF -> 00: General purpose output push-pull
  GPIOB_CRL &=~(0b1111<<4);
  GPIOB_CRL |= (0b0001<<4);

  //set PB13 as output
  //MODE -> 01: Output mode, max speed 10 MHz
  //CNF -> 00: General purpose output push-pull
  GPIOB_CRH &=~(0b1111<<20);
  GPIOB_CRH |= (0b0001<<20);

  //set PA1 as input
  //MODE -> 00: Input mode (reset state)
  //CNF -> 01: Floating input (reset state)
  GPIOA_CRL &=~(0b1111<<4);
  GPIOA_CRL |= (0b0100<<4);

  //set PA13 as input
  //MODE -> 00: Input mode (reset state)
  //CNF -> 01: Floating input (reset state)
  GPIOA_CRH &=~(0b1111<<20);
  GPIOA_CRH |= (0b0100<<20);
}
